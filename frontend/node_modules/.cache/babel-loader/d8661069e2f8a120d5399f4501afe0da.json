{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachListeners = void 0;\n\nvar socket_io_1 = require(\"./socket-io\");\n\nvar constants_1 = require(\"./constants\");\n\nvar util_1 = require(\"./util\");\n\nvar bindMessageHandler = function (webSocketInstance, optionsRef, setLastMessage) {\n  webSocketInstance.onmessage = function (message) {\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n\n    setLastMessage(message);\n  };\n};\n\nvar bindOpenHandler = function (webSocketInstance, optionsRef, setReadyState, reconnectCount) {\n  webSocketInstance.onopen = function (event) {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(constants_1.ReadyState.OPEN);\n  };\n};\n\nvar bindCloseHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return function () {};\n  }\n\n  util_1.assertIsWebSocket(webSocketInstance);\n  var reconnectTimeout;\n\n  webSocketInstance.onclose = function (event) {\n    var _a, _b;\n\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(constants_1.ReadyState.CLOSED);\n\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      var reconnectAttempts = (_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n\n      if (reconnectCount.current < reconnectAttempts) {\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, (_b = optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \" + reconnectAttempts + \" exceeded\");\n      }\n    }\n  };\n\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\n\nvar bindErrorHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  var reconnectTimeout;\n\n  webSocketInstance.onerror = function (error) {\n    var _a, _b;\n\n    optionsRef.current.onError && optionsRef.current.onError(error);\n\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose(__assign(__assign({}, error), {\n        code: 1006,\n        reason: \"An error occurred with the EventSource: \" + error,\n        wasClean: false\n      }));\n      setReadyState(constants_1.ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n\n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < ((_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT)) {\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, (_b = optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \" + optionsRef.current.reconnectAttempts + \" exceeded\");\n      }\n    }\n  };\n\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\n\nexports.attachListeners = function (webSocketInstance, setters, optionsRef, reconnect, reconnectCount, sendMessage) {\n  var setLastMessage = setters.setLastMessage,\n      setReadyState = setters.setReadyState;\n  var interval;\n  var cancelReconnectOnClose;\n  var cancelReconnectOnError;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = socket_io_1.setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, optionsRef, setLastMessage);\n  bindOpenHandler(webSocketInstance, optionsRef, setReadyState, reconnectCount);\n  cancelReconnectOnClose = bindCloseHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  cancelReconnectOnError = bindErrorHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  return function () {\n    setReadyState(constants_1.ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};","map":{"version":3,"sources":["../../src/lib/attach-listener.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAOA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAOA,IAAM,kBAAkB,GAAG,UACzB,iBADyB,EAEzB,UAFyB,EAGzB,cAHyB,EAGgB;AAEzC,EAAA,iBAAiB,CAAC,SAAlB,GAA8B,UAAC,OAAD,EAAsC;AAClE,IAAA,UAAU,CAAC,OAAX,CAAmB,SAAnB,IAAgC,UAAU,CAAC,OAAX,CAAmB,SAAnB,CAA6B,OAA7B,CAAhC;;AACA,QAAI,OAAO,UAAU,CAAC,OAAX,CAAmB,MAA1B,KAAqC,UAArC,IAAmD,UAAU,CAAC,OAAX,CAAmB,MAAnB,CAA0B,OAA1B,MAAuC,IAA9F,EAAoG;AAClG;AACD;;AACD,IAAA,cAAc,CAAC,OAAD,CAAd;AACD,GAND;AAOD,CAZD;;AAcA,IAAM,eAAe,GAAG,UACtB,iBADsB,EAEtB,UAFsB,EAGtB,aAHsB,EAItB,cAJsB,EAIkB;AAExC,EAAA,iBAAiB,CAAC,MAAlB,GAA2B,UAAC,KAAD,EAAiC;AAC1D,IAAA,UAAU,CAAC,OAAX,CAAmB,MAAnB,IAA6B,UAAU,CAAC,OAAX,CAAmB,MAAnB,CAA0B,KAA1B,CAA7B;AACA,IAAA,cAAc,CAAC,OAAf,GAAyB,CAAzB;AACA,IAAA,aAAa,CAAC,WAAA,CAAA,UAAA,CAAW,IAAZ,CAAb;AACD,GAJD;AAKD,CAXD;;AAaA,IAAM,gBAAgB,GAAG,UACvB,iBADuB,EAEvB,UAFuB,EAGvB,aAHuB,EAIvB,SAJuB,EAKvB,cALuB,EAKiB;AAExC,MAAI,WAAA,CAAA,sBAAA,IAA0B,iBAAiB,YAAY,WAA3D,EAAwE;AACtE,WAAO,YAAA,CAAQ,CAAf;AACD;;AACD,EAAA,MAAA,CAAA,iBAAA,CAAkB,iBAAlB;AACA,MAAI,gBAAJ;;AAEA,EAAA,iBAAiB,CAAC,OAAlB,GAA4B,UAAC,KAAD,EAAkC;;;AAC5D,IAAA,UAAU,CAAC,OAAX,CAAmB,OAAnB,IAA8B,UAAU,CAAC,OAAX,CAAmB,OAAnB,CAA2B,KAA3B,CAA9B;AACA,IAAA,aAAa,CAAC,WAAA,CAAA,UAAA,CAAW,MAAZ,CAAb;;AACA,QAAI,UAAU,CAAC,OAAX,CAAmB,eAAnB,IAAsC,UAAU,CAAC,OAAX,CAAmB,eAAnB,CAAmC,KAAnC,CAA1C,EAAqF;AACnF,UAAM,iBAAiB,GAAA,CAAA,EAAA,GAAG,UAAU,CAAC,OAAX,CAAmB,iBAAtB,MAAuC,IAAvC,IAAuC,EAAA,KAAA,KAAA,CAAvC,GAAuC,EAAvC,GAA2C,WAAA,CAAA,uBAAlE;;AACA,UAAI,cAAc,CAAC,OAAf,GAAyB,iBAA7B,EAAgD;AAC9C,QAAA,gBAAgB,GAAG,MAAM,CAAC,UAAP,CAAkB,YAAA;AACnC,UAAA,cAAc,CAAC,OAAf;AACA,UAAA,SAAS;AACV,SAHkB,EAGlB,CAAA,EAAA,GAAE,UAAU,CAAC,OAAX,CAAmB,iBAArB,MAAsC,IAAtC,IAAsC,EAAA,KAAA,KAAA,CAAtC,GAAsC,EAAtC,GAA0C,WAAA,CAAA,6BAHxB,CAAnB;AAID,OALD,MAKO;AACL,QAAA,UAAU,CAAC,OAAX,CAAmB,eAAnB,IAAsC,UAAU,CAAC,OAAX,CAAmB,eAAnB,CAAmC,iBAAnC,CAAtC;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,+BAA6B,iBAA7B,GAA8C,WAA3D;AACD;AACF;AACF,GAfD;;AAiBA,SAAO,YAAA;AAAM,WAAA,gBAAgB,IAAI,MAAM,CAAC,YAAP,CAApB,gBAAoB,CAApB;AAAyD,GAAtE;AACD,CA/BD;;AAiCA,IAAM,gBAAgB,GAAG,UACvB,iBADuB,EAEvB,UAFuB,EAGvB,aAHuB,EAIvB,SAJuB,EAKvB,cALuB,EAKiB;AAExC,MAAI,gBAAJ;;AAEA,EAAA,iBAAiB,CAAC,OAAlB,GAA4B,UAAC,KAAD,EAAkC;;;AAC5D,IAAA,UAAU,CAAC,OAAX,CAAmB,OAAnB,IAA8B,UAAU,CAAC,OAAX,CAAmB,OAAnB,CAA2B,KAA3B,CAA9B;;AACA,QAAI,WAAA,CAAA,sBAAA,IAA0B,iBAAiB,YAAY,WAA3D,EAAwE;AACtE,MAAA,UAAU,CAAC,OAAX,CAAmB,OAAnB,IAA8B,UAAU,CAAC,OAAX,CAAmB,OAAnB,CAA0B,QAAA,CAAA,QAAA,CAAA,EAAA,EACnD,KADmD,CAAA,EAC9C;AACR,QAAA,IAAI,EAAE,IADE;AAER,QAAA,MAAM,EAAE,6CAA2C,KAF3C;AAGR,QAAA,QAAQ,EAAE;AAHF,OAD8C,CAA1B,CAA9B;AAOA,MAAA,aAAa,CAAC,WAAA,CAAA,UAAA,CAAW,MAAZ,CAAb;AACA,MAAA,iBAAiB,CAAC,KAAlB;AACD;;AAED,QAAI,UAAU,CAAC,OAAX,CAAmB,YAAvB,EAAqC;AACnC,UAAI,cAAc,CAAC,OAAf,IAAyB,CAAA,EAAA,GAAC,UAAU,CAAC,OAAX,CAAmB,iBAApB,MAAqC,IAArC,IAAqC,EAAA,KAAA,KAAA,CAArC,GAAqC,EAArC,GAAyC,WAAA,CAAA,uBAAlE,CAAJ,EAAgG;AAC9F,QAAA,gBAAgB,GAAG,MAAM,CAAC,UAAP,CAAkB,YAAA;AACnC,UAAA,cAAc,CAAC,OAAf;AACA,UAAA,SAAS;AACV,SAHkB,EAGlB,CAAA,EAAA,GAAE,UAAU,CAAC,OAAX,CAAmB,iBAArB,MAAsC,IAAtC,IAAsC,EAAA,KAAA,KAAA,CAAtC,GAAsC,EAAtC,GAA0C,WAAA,CAAA,6BAHxB,CAAnB;AAID,OALD,MAKO;AACL,QAAA,UAAU,CAAC,OAAX,CAAmB,eAAnB,IAAsC,UAAU,CAAC,OAAX,CAAmB,eAAnB,CAAmC,UAAU,CAAC,OAAX,CAAmB,iBAAtD,CAAtC;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,+BAA6B,UAAU,CAAC,OAAX,CAAmB,iBAAhD,GAAiE,WAA9E;AACD;AACF;AACF,GAzBD;;AA2BA,SAAO,YAAA;AAAM,WAAA,gBAAgB,IAAI,MAAM,CAAC,YAAP,CAApB,gBAAoB,CAApB;AAAyD,GAAtE;AACD,CArCD;;AAuCa,OAAA,CAAA,eAAA,GAAkB,UAC3B,iBAD2B,EAE3B,OAF2B,EAG3B,UAH2B,EAI3B,SAJ2B,EAK3B,cAL2B,EAM3B,WAN2B,EAMH;AAElB,MAAA,cAAc,GAAoB,OAAO,CAA3B,cAAd;AAAA,MAAgB,aAAa,GAAK,OAAO,CAAZ,aAA7B;AAER,MAAI,QAAJ;AACA,MAAI,sBAAJ;AACA,MAAI,sBAAJ;;AAEA,MAAI,UAAU,CAAC,OAAX,CAAmB,YAAvB,EAAqC;AACnC,IAAA,QAAQ,GAAG,WAAA,CAAA,iBAAA,CAAkB,WAAlB,CAAX;AACD;;AAED,EAAA,kBAAkB,CAChB,iBADgB,EAEhB,UAFgB,EAGhB,cAHgB,CAAlB;AAMA,EAAA,eAAe,CACb,iBADa,EAEb,UAFa,EAGb,aAHa,EAIb,cAJa,CAAf;AAOA,EAAA,sBAAsB,GAAG,gBAAgB,CACvC,iBADuC,EAEvC,UAFuC,EAGvC,aAHuC,EAIvC,SAJuC,EAKvC,cALuC,CAAzC;AAQA,EAAA,sBAAsB,GAAG,gBAAgB,CACvC,iBADuC,EAEvC,UAFuC,EAGvC,aAHuC,EAIvC,SAJuC,EAKvC,cALuC,CAAzC;AAQA,SAAO,YAAA;AACL,IAAA,aAAa,CAAC,WAAA,CAAA,UAAA,CAAW,OAAZ,CAAb;AACA,IAAA,sBAAsB;AACtB,IAAA,sBAAsB;AACtB,IAAA,iBAAiB,CAAC,KAAlB;AACA,QAAI,QAAJ,EAAc,aAAa,CAAC,QAAD,CAAb;AACf,GAND;AAOD,CAtDY","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attachListeners = void 0;\nvar socket_io_1 = require(\"./socket-io\");\nvar constants_1 = require(\"./constants\");\nvar util_1 = require(\"./util\");\nvar bindMessageHandler = function (webSocketInstance, optionsRef, setLastMessage) {\n    webSocketInstance.onmessage = function (message) {\n        optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n        if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n            return;\n        }\n        setLastMessage(message);\n    };\n};\nvar bindOpenHandler = function (webSocketInstance, optionsRef, setReadyState, reconnectCount) {\n    webSocketInstance.onopen = function (event) {\n        optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n        reconnectCount.current = 0;\n        setReadyState(constants_1.ReadyState.OPEN);\n    };\n};\nvar bindCloseHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        return function () { };\n    }\n    util_1.assertIsWebSocket(webSocketInstance);\n    var reconnectTimeout;\n    webSocketInstance.onclose = function (event) {\n        var _a, _b;\n        optionsRef.current.onClose && optionsRef.current.onClose(event);\n        setReadyState(constants_1.ReadyState.CLOSED);\n        if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n            var reconnectAttempts = (_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n            if (reconnectCount.current < reconnectAttempts) {\n                reconnectTimeout = window.setTimeout(function () {\n                    reconnectCount.current++;\n                    reconnect();\n                }, (_b = optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n            }\n            else {\n                optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n                console.warn(\"Max reconnect attempts of \" + reconnectAttempts + \" exceeded\");\n            }\n        }\n    };\n    return function () { return reconnectTimeout && window.clearTimeout(reconnectTimeout); };\n};\nvar bindErrorHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n    var reconnectTimeout;\n    webSocketInstance.onerror = function (error) {\n        var _a, _b;\n        optionsRef.current.onError && optionsRef.current.onError(error);\n        if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n            optionsRef.current.onClose && optionsRef.current.onClose(__assign(__assign({}, error), { code: 1006, reason: \"An error occurred with the EventSource: \" + error, wasClean: false }));\n            setReadyState(constants_1.ReadyState.CLOSED);\n            webSocketInstance.close();\n        }\n        if (optionsRef.current.retryOnError) {\n            if (reconnectCount.current < ((_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT)) {\n                reconnectTimeout = window.setTimeout(function () {\n                    reconnectCount.current++;\n                    reconnect();\n                }, (_b = optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n            }\n            else {\n                optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts);\n                console.warn(\"Max reconnect attempts of \" + optionsRef.current.reconnectAttempts + \" exceeded\");\n            }\n        }\n    };\n    return function () { return reconnectTimeout && window.clearTimeout(reconnectTimeout); };\n};\nexports.attachListeners = function (webSocketInstance, setters, optionsRef, reconnect, reconnectCount, sendMessage) {\n    var setLastMessage = setters.setLastMessage, setReadyState = setters.setReadyState;\n    var interval;\n    var cancelReconnectOnClose;\n    var cancelReconnectOnError;\n    if (optionsRef.current.fromSocketIO) {\n        interval = socket_io_1.setUpSocketIOPing(sendMessage);\n    }\n    bindMessageHandler(webSocketInstance, optionsRef, setLastMessage);\n    bindOpenHandler(webSocketInstance, optionsRef, setReadyState, reconnectCount);\n    cancelReconnectOnClose = bindCloseHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n    cancelReconnectOnError = bindErrorHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n    return function () {\n        setReadyState(constants_1.ReadyState.CLOSING);\n        cancelReconnectOnClose();\n        cancelReconnectOnError();\n        webSocketInstance.close();\n        if (interval)\n            clearInterval(interval);\n    };\n};\n//# sourceMappingURL=attach-listener.js.map"]},"metadata":{},"sourceType":"script"}